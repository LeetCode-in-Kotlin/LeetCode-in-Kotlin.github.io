[![](https://img.shields.io/github/stars/javadev/LeetCode-in-Kotlin?label=Stars&style=flat-square)](https://github.com/javadev/LeetCode-in-Kotlin)
[![](https://img.shields.io/github/forks/javadev/LeetCode-in-Kotlin?label=Fork%20me%20on%20GitHub%20&style=flat-square)](https://github.com/javadev/LeetCode-in-Kotlin/fork)

## 2875\. Minimum Size Subarray in Infinite Array

Medium

You are given a **0-indexed** array `nums` and an integer `target`.

A **0-indexed** array `infinite_nums` is generated by infinitely appending the elements of `nums` to itself.

Return _the length of the **shortest** subarray of the array_ `infinite_nums` _with a sum equal to_ `target`_._ If there is no such subarray return `-1`.

**Example 1:**

**Input:** nums = [1,2,3], target = 5

**Output:** 2

**Explanation:** In this example infinite\_nums = [1,2,3,1,2,3,1,2,...]. The subarray in the range [1,2], has the sum equal to target = 5 and length = 2. It can be proven that 2 is the shortest length of a subarray with sum equal to target = 5.

**Example 2:**

**Input:** nums = [1,1,1,2,3], target = 4

**Output:** 2

**Explanation:** In this example infinite\_nums = [1,1,1,2,3,1,1,1,2,3,1,1,...]. The subarray in the range [4,5], has the sum equal to target = 4 and length = 2. It can be proven that 2 is the shortest length of a subarray with sum equal to target = 4.

**Example 3:**

**Input:** nums = [2,4,6,8], target = 3

**Output:** -1

**Explanation:** In this example infinite\_nums = [2,4,6,8,2,4,6,8,...]. It can be proven that there is no subarray with sum equal to target = 3.

**Constraints:**

*   <code>1 <= nums.length <= 10<sup>5</sup></code>
*   <code>1 <= nums[i] <= 10<sup>5</sup></code>
*   <code>1 <= target <= 10<sup>9</sup></code>

## Solution

```kotlin
import kotlin.math.min

class Solution {
    fun minSizeSubarray(nums: IntArray, target: Int): Int {
        var sum = 0
        for (num in nums) {
            sum += num
        }
        if (sum == 0) {
            return -1
        }
        val result = (target / sum) * nums.size
        sum = target % sum
        var currentSum = 0
        var min = nums.size
        var start = 0
        for (i in 0 until nums.size * 2) {
            currentSum += nums[i % nums.size]
            while (currentSum > sum) {
                currentSum -= nums[start % nums.size]
                start++
            }
            if (currentSum == sum) {
                min = min(min, i - start + 1)
            }
        }
        if (min == nums.size) {
            return -1
        }
        return result + min
    }
}
```